import numpy as npx1 = 69.49x2 = x3 = 103.21theta = np.radians(30) ## angle of T2 & T3 from nLDMd = 345LDM = np.radians(LDMd)print(LDMd)ESC_Fwd_Max = 2500 ## = value assigned to ESC for max forward speedESC_Fwd_Min = 1501 #? ## = value assigned to ESC for min forward speedESC_Rev_Max = 1499 #? ## = value assigned to ESC for max reverse speedESC_Rev_Min = 500T_cut_off = 0.1Speed_PC = 1# ESC_Fwd_Min + ((ESC_Fwd_Max - ESC_Fwd_Min)*Speed_PC)## simultaneous equation solver using linear algebra: ax = b## 1st equation for '1' force in LDM direction (therefore gives ratios of TA:TB:TC - multiply by F)#					check this	-	-	-	-	^	^	^	^	^	^	^	^	^	^	^	^	^## 2nd equation for no force at 90deg to LDM## 3rd for no force rotationa = np.array([[np.sin(LDM),-np.cos(theta-LDM),np.cos(theta+LDM)] , [np.cos(LDM),-np.sin(theta-LDM),-np.sin(theta+LDM)] , [x1,x2,x3]])b = np.array([1,0,0])T = np.linalg.solve(a, b) # = (TA, TB, TC) ?? - check if need to be A, B & C or if it can handle all angles(TA, TB, TC) = Tprint('T = ',T)TiS = []for Ti in T:    if -T_cut_off < Ti < T_cut_off:	# Check likely values close to 0        TiS.append(0)    if Ti > T_cut_off:        TiS.append(ESC_Fwd_Min + ((ESC_Fwd_Max - ESC_Fwd_Min)*Speed_PC) * Ti / max(abs(T))) # check this    if Ti < -T_cut_off:        TiS.append(ESC_Rev_Min + ((ESC_Rev_Max - ESC_Rev_Min)*Speed_PC) * -Ti / max(abs(T)))print('TiS = ', TiS)# can we do this as a for loop?# for i in T: - but couldn't assign correct value to T1S or T2S for example, unless these were in a list too. even then would have to use a while loop. as there're only 3 Ts I think it's ok like this.if -T_cut_off < TA < T_cut_off:	# Check likely values close to 0   T1S = 0          # Don't bother turning on at all if close to 0   TA = 0           # But messes with moments - check in wet testsif TA > T_cut_off:	T1S = ESC_Fwd_Min + ((ESC_Fwd_Max - ESC_Fwd_Min)*Speed_PC) * TA / max(abs(T)) # check thisif TA < -T_cut_off:	T1S = ESC_Rev_Min + ((ESC_Rev_Max - ESC_Rev_Min)*Speed_PC) * -TA / max(abs(T))if -T_cut_off < TB < T_cut_off:    T2S = 0    TB = 0if TB > T_cut_off:	T2S = ESC_Fwd_Min + ((ESC_Fwd_Max - ESC_Fwd_Min)*Speed_PC) * TB / max(abs(T)) # check thisif TB < -T_cut_off:	T2S = ESC_Rev_Min + ((ESC_Rev_Max - ESC_Rev_Min)*Speed_PC) * -TB / max(abs(T))	if -T_cut_off < TC < T_cut_off:    T3S = 0    TC = 0if TC > T_cut_off:	T3S = ESC_Fwd_Min + ((ESC_Fwd_Max - ESC_Fwd_Min)*Speed_PC) * TC / max(abs(T)) # check thisif TC < -T_cut_off:	T3S = ESC_Rev_Min + ((ESC_Rev_Max - ESC_Rev_Min)*Speed_PC) * -TC / max(abs(T))print('T1S =', T1S)print('T2S =', T2S)print('T3S =', T3S)X = TA*np.sin(LDM) - TB*np.cos(theta-LDM) + TC*np.cos(theta+LDM)Y = TA*np.cos(LDM) - TB*np.sin(theta-LDM) - TC*np.sin(theta+LDM)M = x1*TA + x2*TB + x3*TCprint()print('X = ', X)print('Y = ', Y)print('M = ', M)# T = np.cos(np.radians(30)) + np.cos(np.radians(30))# Y = np.sin(np.radians(30)) - np.sin(np.radians(30))# print(T)# print(Y)